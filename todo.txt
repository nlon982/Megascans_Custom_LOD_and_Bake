- so the gui should give all the maps to bake 
	i.e. pass maps_to_bake_dict to execute_fix (instead of just 'displacement type' and 'displacement resolution')
	Either they all use the same resolution, or resolution needs to be apart of "maps to bake dict"

- perhaps 'execute_fix' could be renamed 'execute'


- do hou.ui.displayMessage for __init__ to override existing exceptions (perhaps it can USE existing exceptions! very cool) (done)

- don't be afraid to restructure code and re-think - I want it as simple as possible

- for EXTRA flair, I can indeed have it use the highest megascans resoltuion as defualt in ui (use highest resolution function I made)
- for EXTRA flair, add a label at the beginning of the UI which gives houdini path to megascans asset (nielsons heuristics), and os's folder path

- add collapsable (to select what maps to bake) to UI


- do the post render script thing (think big brain)

- Final: compile list of qustion + process for muggy


- perhaps add a clause so it doesn't rerender maps which are already rendered with this tool (that would be problematic? i.e. what if the user
wants to rerender because something went wrong) - perhaps a tickbox can be added saying "override any existing renders made with this tool"

----

Figure out what maps Bridge gives (or the gist) by looking at Bridge
Figure out the names of the maps

All with the goal of sorting out the houdini map names and houdini parameter names dict

Perhaps this is something I can do with Muggy

---

There's no point in maps_to_bake_dict having maps it doesn't want to bake in there, since they're false by default (I guess it's foolproof)

----





THEN look at the write up I can do for big framework (pictures explaining i.e. the ones I sent to kyle / muggy, perhaps a video of it in action)
illustrate the purpose 1) it can describe node setups 'easily' (if you know it) as oppose to existing functions
2) it's a means to write down node setups and use them later in code i.e. my first use case was iterating through a folder of materials, and whenever it came
across a map of displacement, I wanted it to create so-and-so node setup
(I see now alternatively, I could of passed a function object around, but knowing that, that's still not as elegant as this)